<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:og="http://ogp.me/ns#" xmlns:fb="https://www.facebook.com/2008/fbml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Position Independent Code (PIC) in shared libraries - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="http://eli.thegreenplace.net/favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/bootstrap.css" type="text/css">
    <link href="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/font-awesome.css" rel="stylesheet">

    <link href="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/style.css" type="text/css">

        <link href="http://eli.thegreenplace.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Eli Bendersky's website ATOM Feed">

<script src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/analytics.js" async=""></script><script src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/embed.js" async="" type="text/javascript"></script></head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://eli.thegreenplace.net/" class="navbar-brand">
                <img src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/logosmall.png" width="32"> 
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="http://eli.thegreenplace.net/pages/about">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="http://eli.thegreenplace.net/pages/code">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Code</span>
                    </a>
                </li>
                <li>
                    <a href="http://eli.thegreenplace.net/archives/all">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries" rel="bookmark" title="Permalink to Position Independent Code (PIC) in shared libraries">
                        Position Independent Code (PIC) in shared libraries
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> November 03, 2011 at 06:14</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="http://eli.thegreenplace.net/tag/articles">Articles</a>
        ,
    <a href="http://eli.thegreenplace.net/tag/assembly">Assembly</a>
        ,
    <a href="http://eli.thegreenplace.net/tag/c-c">C &amp; C++</a>
        ,
    <a href="http://eli.thegreenplace.net/tag/linkers-and-loaders">Linkers and loaders</a>
        ,
    <a href="http://eli.thegreenplace.net/tag/linux">Linux</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                
        <p>I've described the need for special handling of shared libraries while loading them into the process's address space in a <a class="reference external" href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/">previous article</a>.
 Briefly, when the linker creates a shared library, it doesn't know in 
advance where it might be loaded. This creates a problem for the data 
and code references within the library, which should be somehow made to 
point to the correct memory locations.</p>
<p>There are two main approaches to solve this problem in Linux ELF shared libraries:</p>
<ol class="arabic simple">
<li>Load-time relocation</li>
<li>Position independent code (PIC)</li>
</ol>
<p>Load-time relocation was <a class="reference external" href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/">already covered</a>. Here, I want to explain the second approach - PIC.</p>
<p>I originally planned to focus on both x86 and x64 (a.k.a. x86-64) in 
this article, but as it grew longer and longer I decided it won't be 
practical. So, it will explain only how PIC works on x86, picking this 
older architecture specifically because (unlike x64) it wasn't designed 
with PIC in mind, so implementing PIC on it is a bit trickier. A future 
(hopefully much shorter) article will build upon the foundation of this 
one to explain how PIC is implemented on x64.</p>
<div class="section" id="some-problems-of-load-time-relocation">
<h3>Some problems of load-time relocation</h3>
<p>As we've seen in the previous article, load-time relocation is a 
fairly straightforward method, and it works. PIC, however, is much more 
popular nowadays, and is usually the recommended method of building 
shared libraries. Why is this so?</p>
<p>Load-time relocation has a couple of problems: it takes time to 
perform, and it makes the text section of the library non-shareable.</p>
<p>First, the performance problem. If a shared library was linked with 
load-time relocation entries, it will take some time to actually perform
 these relocations when the application is loaded. You may think that 
the cost shouldn't be too large - after all, the loader doesn't have to 
scan through the whole text section - it should only look at the 
relocation entries. But if a complex piece of software loads multiple 
large shared libraries at start-up, and each shared library must first 
have its load-time relocations applied, these costs can build up and 
result in a noticeable delay in the start-up time of the application.</p>
<p>Second, the non-shareable text section problem, which is somewhat 
more serious. One of the main points of having shared libraries in the 
first place, is saving RAM. Some common shared libraries are used by 
multiple applications. If the text section (where the code is) of the 
shared library can only be loaded into memory once (and then mapped into
 the virtual memories of many processes), considerable amounts of RAM 
can be saved. But this is not possible with load-time relocation, since 
when using this technique the text section has to be modified at 
load-time to apply the relocations. Therefore, for each application that
 loaded this shared library, it will have to be wholly placed in RAM 
again <a class="footnote-reference" href="#id9" id="id1">[1]</a>. Different applications won't be able to really share it.</p>
<p>Moreover, having a writable text section (it must be kept writable, 
to allow the dynamic loader to perform the relocations) poses a security
 risk, making it easier to exploit the application.</p>
<p>As we'll see in this article, PIC mostly mitigates these problems.</p>
</div>
<div class="section" id="pic-introduction">
<h3>PIC - introduction</h3>
<p>The idea behind PIC is simple - add an additional level of 
indirection to all global data and function references in the code. By 
cleverly utilizing some artifacts of the linking and loading processes, 
it's possible to make the text section of the shared library truly <em>position independent</em>,
 in the sense that it can be easily mapped into different memory 
addresses without needing to change one bit. In the next few sections I 
will explain in detail how this feat is achieved.</p>
</div>
<div class="section" id="key-insight-1-offset-between-text-and-data-sections">
<h3>Key insight #1 - offset between text and data sections</h3>
<p>One of the key insights on which PIC relies is the offset between the text and data sections, known to the linker <em>at link-time</em>.
 When the linker combines several object files together, it collects 
their sections (for example, all text sections get unified into a single
 large text section). Therefore, the linker knows both about the sizes 
of the sections and about their relative locations.</p>
<p>For example, the text section may be immediately followed by the data
 section, so the offset from any given instruction in the text section 
to the beginning of the data section is just the size of the text 
section minus the offset of the instruction from the beginning of the 
text section - and both these quantities are known to the linker.</p>
<img class="align-center" src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/code_data_offset_1.png">
<p>In the diagram above, the code section was loaded into some address 
(unknown at link-time) 0xXXXX0000 (the X-es literally mean "don't 
care"), and the data section right after it at offset 0xXXXXF000. Then, 
if some instruction at offset 0x80 in the code section wants to 
reference stuff in the data section, the linker knows the relative 
offset (0xEF80 in this case) and can encode it in the instruction.</p>
<p>Note that it wouldn't matter if another section was placed between 
the code and data sections, or if the data section preceded the code 
section. Since the linker knows the sizes of all sections and decides 
where to place them, the insight holds.</p>
</div>
<div class="section" id="key-insight-2-making-an-ip-relative-offset-work-on-x86">
<h3>Key insight #2 - making an IP-relative offset work on x86</h3>
<p>The above is only useful if we can actually put the relative offset to work. But data references (i.e. in the <tt class="docutils literal">mov</tt> instruction) on x86 require absolute addresses. So, what can we do?</p>
<p>If we have a relative address and need an absolute address, what's 
missing is the value of the instruction pointer (since, by definition, 
the <em>relative</em> address is relative to the instruction's 
location). There's no instruction to obtain the value of the instruction
 pointer on x86, but we can use a simple trick to get it. Here's some 
assembly pseudo-code that demonstrates it:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">    call TMPLABEL
TMPLABEL:
    pop ebx
</pre></div>
<p>What happens here is:</p>
<ol class="arabic simple">
<li>The CPU executes <tt class="docutils literal">call TMPLABEL</tt>, which causes it to save the address of the next instruction (the <tt class="docutils literal">pop ebx</tt>) on stack and jump to the label.</li>
<li>Since the instruction at the label is <tt class="docutils literal">pop ebx</tt>, it gets executed next. It pops a value from the stack into <tt class="docutils literal">ebx</tt>. But this value is the address of the instruction itself, so <tt class="docutils literal">ebx</tt> now effectively contains the value of the instruction pointer.</li>
</ol>
</div>
<div class="section" id="the-global-offset-table-got">
<h3>The Global Offset Table (GOT)</h3>
<p>With this at hand, we can finally get to the implementation of 
position-independent data addressing on x86. It is accomplished by means
 of a "global offset table", or in short GOT.</p>
<p>A GOT is simply a table of addresses, residing in the data section. 
Suppose some instruction in the code section wants to refer to a 
variable. Instead of referring to it directly by absolute address (which
 would require a relocation), it refers to an entry in the GOT. Since 
the GOT is in a known place in the data section, this reference is 
relative and known to the linker. The GOT entry, in turn, will contain 
the absolute address of the variable:</p>
<img class="align-center" src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/code_data_got_1.png">
<p>In pseudo-assembly, we replace an absolute addressing instruction:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">; Place the value of the variable in edx
mov edx, [ADDR_OF_VAR]
</pre></div>
<p>With displacement addressing from a register, along with an extra indirection:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">; 1. Somehow get the address of the GOT into ebx
lea ebx, ADDR_OF_GOT

; 2. Suppose ADDR_OF_VAR is stored at offset 0x10
;    in the GOT. Then this will place ADDR_OF_VAR
;    into edx.
mov edx, DWORD PTR [ebx + 0x10]

; 3. Finally, access the variable and place its
;    value into edx.
mov edx, DWORD PTR [edx]
</pre></div>
<p>So, we've gotten rid of a relocation in the code section by 
redirecting variable references through the GOT. But we've also created a
 relocation in the data section. Why? Because the GOT still has to 
contain the absolute address of the variable for the scheme described 
above to work. So what have we gained?</p>
<p>A lot, it turns out. A relocation in the data section is much less 
problematic than one in the code section, for two reasons (which 
directly address the two main problems of load-time relocation of code 
described in the beginning of the article):</p>
<ol class="arabic simple">
<li>Relocations in the code section are required <em>per variable reference</em>, while in the GOT we only need to relocate once <em>per variable</em>. There are likely much more references to variables than variables, so this is more efficient.</li>
<li>The data section is writable and not shared between processes 
anyway, so adding relocations to it does no harm. Moving relocations 
from the code section, however, allows to make it read-only and share it
 between processes.</li>
</ol>
</div>
<div class="section" id="pic-with-data-references-through-got-an-example">
<h3>PIC with data references through GOT - an example</h3>
<p>I will now show a complete example that demonstrates the mechanics of PIC:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">int</span> myglob = <span style="color: #007f7f">42</span>;

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">ml_func</span>(<span style="color: #00007f; font-weight: bold">int</span> a, <span style="color: #00007f; font-weight: bold">int</span> b)
{
    <span style="color: #00007f; font-weight: bold">return</span> myglob + a + b;
}
</pre></div>
<p>This chunk of code will be compiled into a shared library (using the <tt class="docutils literal"><span class="pre">-fpic</span></tt> and <tt class="docutils literal"><span class="pre">-shared</span></tt> flags as appropriate) named <tt class="docutils literal">libmlpic_dataonly.so</tt>.</p>
<p>Let's take a look at its disassembly, focusing on the <tt class="docutils literal">ml_func</tt> function:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">0000043c &lt;ml_func&gt;:
 43c:   55                      push   ebp
 43d:   89 e5                   mov    ebp,esp
 43f:   e8 16 00 00 00          call   45a &lt;__i686.get_pc_thunk.cx&gt;
 444:   81 c1 b0 1b 00 00       add    ecx,0x1bb0
 44a:   8b 81 f0 ff ff ff       mov    eax,DWORD PTR [ecx-0x10]
 450:   8b 00                   mov    eax,DWORD PTR [eax]
 452:   03 45 08                add    eax,DWORD PTR [ebp+0x8]
 455:   03 45 0c                add    eax,DWORD PTR [ebp+0xc]
 458:   5d                      pop    ebp
 459:   c3                      ret

0000045a &lt;__i686.get_pc_thunk.cx&gt;:
 45a:   8b 0c 24                mov    ecx,DWORD PTR [esp]
 45d:   c3                      ret
</pre></div>
<p>I'm going to refer to instructions by their addresses (the left-most 
number in the disassembly). This address is the offset from the load 
address of the shared library.</p>
<ul class="simple">
<li>At <tt class="docutils literal">43f</tt>, the address of the next instruction is placed into <tt class="docutils literal">ecx</tt>, by means of the technique described in the "key insight #2" section above.</li>
<li>At <tt class="docutils literal">444</tt>, a known constant offset from the instruction to the place where the GOT is located is added to <tt class="docutils literal">ecx</tt>. So <tt class="docutils literal">ecx</tt> now serves as a base pointer to GOT.</li>
<li>At <tt class="docutils literal">44a</tt>, a value is taken from <tt class="docutils literal">[ecx - 0x10]</tt>, which is a GOT entry, and placed into <tt class="docutils literal">eax</tt>. This is the address of <tt class="docutils literal">myglob</tt>.</li>
<li>At <tt class="docutils literal">450</tt> the indirection is done, and the <em>value</em> of <tt class="docutils literal">myglob</tt> is placed into <tt class="docutils literal">eax</tt>.</li>
<li>Later the parameters <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> are added to <tt class="docutils literal">myglob</tt> and the value is returned (by keeping it in <tt class="docutils literal">eax</tt>).</li>
</ul>
<p>We can also query the shared library with <tt class="docutils literal">readelf <span class="pre">-S</span></tt> to see where the GOT section was placed:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">Section Headers:
  [Nr] Name     Type            Addr     Off    Size   ES Flg Lk Inf Al
  &lt;snip&gt;
  [19] .got     PROGBITS        00001fe4 000fe4 000010 04  WA  0   0  4
  [20] .got.plt PROGBITS        00001ff4 000ff4 000014 04  WA  0   0  4
  &lt;snip&gt;
</pre></div>
<p>Let's do some math to check the computation done by the compiler to find <tt class="docutils literal">myglob</tt>. As I mentioned above, the call to <tt class="docutils literal">__i686.get_pc_thunk.cx</tt> places the address of the next instruction into <tt class="docutils literal">ecx</tt>. That address is <tt class="docutils literal">0x444</tt> <a class="footnote-reference" href="#id10" id="id2">[2]</a>. The next instruction then adds <tt class="docutils literal">0x1bb0</tt> to it, and the result in <tt class="docutils literal">ecx</tt> is going to be <tt class="docutils literal">0x1ff4</tt>. Finally, to actually obtain the GOT entry holding the address of <tt class="docutils literal">myglob</tt>, displacement addressing is used - <tt class="docutils literal">[ecx - 0x10]</tt>, so the entry is at <tt class="docutils literal">0x1fe4</tt>, which is the first entry in the GOT according to the section header.</p>
<p>Why there's another section whose name starts with <tt class="docutils literal">.got</tt> will be explained later in the article <a class="footnote-reference" href="#id11" id="id3">[3]</a>. Note that the compiler chooses to point <tt class="docutils literal">ecx</tt>
 to after the GOT and then use negative offsets to obtain entries. This 
is fine, as long as the math works out. And so far it does.</p>
<p>There's something we're still missing, however. How does the address of <tt class="docutils literal">myglob</tt> actually get into the GOT slot at <tt class="docutils literal">0x1fe4</tt>? Recall that I mentioned a relocation, so let's find it:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt; readelf -r libmlpic_dataonly.so

Relocation section '.rel.dyn' at offset 0x2dc contains 5 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00002008  00000008 R_386_RELATIVE
00001fe4  00000406 R_386_GLOB_DAT    0000200c   myglob
&lt;snip&gt;
</pre></div>
<p>Note the relocation section for <tt class="docutils literal">myglob</tt>, pointing to address <tt class="docutils literal">0x1fe4</tt>, as expected. The relocation is of type <tt class="docutils literal">R_386_GLOB_DAT</tt>,
 which simply tells the dynamic loader - "put the actual value of the 
symbol (i.e. its address) into that offset". So everything works out 
nicely. All that's left is to check how it actually looks when the 
library is loaded. We can do this by writing a simple "driver" 
executable that links to <tt class="docutils literal">libmlpic_dataonly.so</tt> and calls <tt class="docutils literal">ml_func</tt>, and then running it through GDB.</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt; gdb driver
[...] skipping output
(gdb) set environment LD_LIBRARY_PATH=.
(gdb) break ml_func
[...]
(gdb) run
Starting program: [...]pic_tests/driver

Breakpoint 1, ml_func (a=1, b=1) at ml_reloc_dataonly.c:5
5         return myglob + a + b;
(gdb) set disassembly-flavor intel
(gdb) disas ml_func
Dump of assembler code for function ml_func:
   0x0013143c &lt;+0&gt;:   push   ebp
   0x0013143d &lt;+1&gt;:   mov    ebp,esp
   0x0013143f &lt;+3&gt;:   call   0x13145a &lt;__i686.get_pc_thunk.cx&gt;
   0x00131444 &lt;+8&gt;:   add    ecx,0x1bb0
=&gt; 0x0013144a &lt;+14&gt;:  mov    eax,DWORD PTR [ecx-0x10]
   0x00131450 &lt;+20&gt;:  mov    eax,DWORD PTR [eax]
   0x00131452 &lt;+22&gt;:  add    eax,DWORD PTR [ebp+0x8]
   0x00131455 &lt;+25&gt;:  add    eax,DWORD PTR [ebp+0xc]
   0x00131458 &lt;+28&gt;:  pop    ebp
   0x00131459 &lt;+29&gt;:  ret
End of assembler dump.
(gdb) i registers
eax            0x1    1
ecx            0x132ff4       1257460
[...] skipping output
</pre></div>
<p>The debugger has entered <tt class="docutils literal">ml_func</tt>, and stopped at IP <tt class="docutils literal">0x0013144a</tt> <a class="footnote-reference" href="#id12" id="id4">[4]</a>. We see that <tt class="docutils literal">ecx</tt> holds the value <tt class="docutils literal">0x132ff4</tt> (which is the address of the instruction plus <tt class="docutils literal">0x1bb0</tt>,
 as explained before). Note that at this point, at runtime, these are 
absolute addresses - the shared library has already been loaded into the
 address space of the process.</p>
<p>So, the GOT entry for <tt class="docutils literal">myglob</tt> is at <tt class="docutils literal">[ecx - 0x10]</tt>. Let's check what's there:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">(gdb) x 0x132fe4
0x132fe4:     0x0013300c
</pre></div>
<p>So, we'd expect <tt class="docutils literal">0x0013300c</tt> to be the address of <tt class="docutils literal">myglob</tt>. Let's verify:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">(gdb) p &amp;myglob
$1 = (int *) 0x13300c
</pre></div>
<p>Indeed, it is!</p>
</div>
<div class="section" id="function-calls-in-pic">
<h3>Function calls in PIC</h3>
<p>Alright, so this is how data addressing works in position independent
 code. But what about function calls? Theoretically, the exact same 
approach could work for function calls as well. Instead of <tt class="docutils literal">call</tt>
 actually containing the address of the function to call, let it contain
 the address of a known GOT entry, and fill in that entry during 
loading.</p>
<p>But this is <em>not</em> how function calls work in PIC. What 
actually happens is a bit more complicated. Before I explain how it's 
done, a few words about the motivation for such a mechanism.</p>
</div>
<div class="section" id="the-lazy-binding-optimization">
<h3>The lazy binding optimization</h3>
<p>When a shared library refers to some function, the real address of 
that function is not known until load time. Resolving this address is 
called <em>binding</em>, and it's something the dynamic loader does when
 it loads the shared library into the process's memory space. This 
binding process is non-trivial, since the loader has to actually <em>look up</em> the function symbol in special tables <a class="footnote-reference" href="#id13" id="id5">[5]</a>.</p>
<p>So, resolving each function takes time. Not a lot of time, but it 
adds up since the amount of functions in libraries is typically much 
larger than the amount of global variables. Moreover, most of these 
resolutions are done in vain, because in a typical run of a program only
 a fraction of functions actually get called (think about various 
functions handling error and special conditions, which typically don't 
get called at all).</p>
<p>So, to speed up this process, a clever lazy binding scheme was 
devised. "Lazy" is a generic name for a family of optimizations in 
computer programming, where work is delayed until the last moment when 
it's actually needed, with the intention of avoiding doing this work if 
its results are never required during a specific run of a program. Good 
examples of laziness are <a class="reference external" href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> and <a class="reference external" href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>.</p>
<p>This lazy binding scheme is attained by adding yet another level of indirection - the PLT.</p>
</div>
<div class="section" id="the-procedure-linkage-table-plt">
<h3>The Procedure Linkage Table (PLT)</h3>
<p>The PLT is part of the executable text section, consisting of a set 
of entries (one for each external function the shared library calls). 
Each PLT entry is a short chunk of executable code. Instead of calling 
the function directly, the code calls an entry in the PLT, which then 
takes care to call the actual function. This arrangement is sometimes 
called a "<a class="reference external" href="http://en.wikipedia.org/wiki/Trampoline_%28computing%29">trampoline</a>".
 Each PLT entry also has a corresponding entry in the GOT which contains
 the actual offset to the function, but only when the dynamic loader 
resolves it. I know this is confusing, but hopefully it will be come 
clearer once I explain the details in the next few paragraphs and 
diagrams.</p>
<p>As the previous section mentioned, PLTs allow lazy resolution of 
functions. When the shared library is first loaded, the function calls 
have not been resolved yet:</p>
<img class="align-center" src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/plt_before.png">
<p>Explanation:</p>
<ul class="simple">
<li>In the code, a function <tt class="docutils literal">func</tt> is called. The compiler translates it to a call to <tt class="docutils literal">func@plt</tt>, which is some N-th entry in the PLT.</li>
<li>The PLT consists of a special first entry, followed by a bunch of 
identically structured entries, one for each function needing 
resolution.</li>
<li>Each PLT entry but the first consists of these parts:<ul>
<li>A jump to a location which is specified in a corresponding GOT entry</li>
<li>Preparation of arguments for a "resolver" routine</li>
<li>Call to the resolver routine, which resides in the first entry of the PLT</li>
</ul>
</li>
<li>The first PLT entry is a call to a resolver routine, which is located in the dynamic loader itself <a class="footnote-reference" href="#id14" id="id6">[6]</a>. This routine resolves the actual address of the function. More on its action a bit later.</li>
<li>Before the function's actual address has been resolved, the Nth GOT 
entry just points to after the jump. This is why this arrow in the 
diagram is colored differently - it's not an actual jump, just a 
pointer.</li>
</ul>
<p>What happens when <tt class="docutils literal">func</tt> is called for the first time is this:</p>
<ul class="simple">
<li><tt class="docutils literal">PLT[n]</tt> is called and jumps to the address pointed to in <tt class="docutils literal">GOT[n]</tt>.</li>
<li>This address points into <tt class="docutils literal">PLT[n]</tt> itself, to the preparation of arguments for the resolver.</li>
<li>The resolver is then called.</li>
<li>The resolver performs resolution of the actual address of <tt class="docutils literal">func</tt>, places its actual address into <tt class="docutils literal">GOT[n]</tt> and calls <tt class="docutils literal">func</tt>.</li>
</ul>
<p>After the first call, the diagram looks a bit differently:</p>
<img class="align-center" src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/plt_after.png">
<p>Note that <tt class="docutils literal">GOT[n]</tt> now points to the actual <tt class="docutils literal">func</tt> <a class="footnote-reference" href="#id15" id="id7">[7]</a> instead of back into the PLT. So, when <tt class="docutils literal">func</tt> is called again:</p>
<ul class="simple">
<li><tt class="docutils literal">PLT[n]</tt> is called and jumps to the address pointed to in <tt class="docutils literal">GOT[n]</tt>.</li>
<li><tt class="docutils literal">GOT[n]</tt> points to <tt class="docutils literal">func</tt>, so this just transfers control to <tt class="docutils literal">func</tt>.</li>
</ul>
<p>In other words, now <tt class="docutils literal">func</tt> is being 
actually called, without going through the resolver, at the cost of one 
additional jump. That's all there is to it, really. This mechanism 
allows lazy resolution of functions, and no resolution at all for 
functions that aren't actually called.</p>
<p>It also leaves the code/text section of the library completely 
position independent, since the only place where an absolute address is 
used is the GOT, which resides in the data section and will be relocated
 by the dynamic loader. Even the PLT itself is PIC, so it can live in 
the read-only text section.</p>
<p>I didn't get into much details regarding the resolver, but it's 
really not important for our purpose here. The resolver is simply a 
chunk of low-level code in the loader that does symbol resolution. The 
arguments prepared for it in each PLT entry, along with a suitable 
relocation entry, help it know about the symbol that needs resolution 
and about the GOT entry to update.</p>
</div>
<div class="section" id="pic-with-function-calls-through-plt-and-got-an-example">
<h3>PIC with function calls through PLT and GOT - an example</h3>
<p>Once again, to fortify the hard-learned theory with a practical 
demonstration, here's a complete example showing function call 
resolution using the mechanism described above. I'll be moving forward a
 bit faster this time.</p>
<p>Here's the code for the shared library:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">int</span> myglob = <span style="color: #007f7f">42</span>;

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">ml_util_func</span>(<span style="color: #00007f; font-weight: bold">int</span> a)
{
    <span style="color: #00007f; font-weight: bold">return</span> a + <span style="color: #007f7f">1</span>;
}

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">ml_func</span>(<span style="color: #00007f; font-weight: bold">int</span> a, <span style="color: #00007f; font-weight: bold">int</span> b)
{
    <span style="color: #00007f; font-weight: bold">int</span> c = b + ml_util_func(a);
    myglob += c;
    <span style="color: #00007f; font-weight: bold">return</span> b + myglob;
}
</pre></div>
<p>This code will be compiled into <tt class="docutils literal">libmlpic.so</tt>, and the focus is going to be on the call to <tt class="docutils literal">ml_util_func</tt> from <tt class="docutils literal">ml_func</tt>. Let's first disassemble <tt class="docutils literal">ml_func</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">00000477 &lt;ml_func&gt;:
 477:   55                      push   ebp
 478:   89 e5                   mov    ebp,esp
 47a:   53                      push   ebx
 47b:   83 ec 24                sub    esp,0x24
 47e:   e8 e4 ff ff ff          call   467 &lt;__i686.get_pc_thunk.bx&gt;
 483:   81 c3 71 1b 00 00       add    ebx,0x1b71
 489:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
 48c:   89 04 24                mov    DWORD PTR [esp],eax
 48f:   e8 0c ff ff ff          call   3a0 &lt;ml_util_func@plt&gt;
 &lt;... snip more code&gt;
</pre></div>
<p>The interesting part is the call to <tt class="docutils literal">ml_util_func@plt</tt>. Note also that the address of GOT is in <tt class="docutils literal">ebx</tt>. Here's what <tt class="docutils literal">ml_util_func@plt</tt> looks like (it's in an executable section called <tt class="docutils literal">.plt</tt>):</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">000003a0 &lt;ml_util_func@plt&gt;:
 3a0:   ff a3 14 00 00 00       jmp    DWORD PTR [ebx+0x14]
 3a6:   68 10 00 00 00          push   0x10
 3ab:   e9 c0 ff ff ff          jmp    370 &lt;_init+0x30&gt;
</pre></div>
<p>Recall that each PLT entry consists of three parts:</p>
<ul class="simple">
<li>A jump to an address specified in GOT (this is the jump to <tt class="docutils literal">[ebx+0x14]</tt>)</li>
<li>Preparation of arguments for the resolver</li>
<li>Call to the resolver</li>
</ul>
<p>The resolver (PLT entry 0) resides at address <tt class="docutils literal">0x370</tt>,
 but it's of no interest to us here. What's more interesting is to see 
what the GOT contains. For that, we first have to do some math.</p>
<p>The "get IP" trick in <tt class="docutils literal">ml_func</tt> was done on address <tt class="docutils literal">0x483</tt>, to which <tt class="docutils literal">0x1b71</tt> is added. So the base of the GOT is at <tt class="docutils literal">0x1ff4</tt>. We can take a peek at the GOT contents with <tt class="docutils literal">readelf</tt> <a class="footnote-reference" href="#id16" id="id8">[8]</a>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt; readelf -x .got.plt libmlpic.so

Hex dump of section '.got.plt':
  0x00001ff4 241f0000 00000000 00000000 86030000 $...............
  0x00002004 96030000 a6030000                   ........
</pre></div>
<p>The GOT entry <tt class="docutils literal">ml_util_func@plt</tt> looks at is at offset <tt class="docutils literal">+0x14</tt>, or <tt class="docutils literal">0x2008</tt>. From above, the word at that location is <tt class="docutils literal">0x3a6</tt>, which is the address of the <tt class="docutils literal">push</tt> instruction in <tt class="docutils literal">ml_util_func@plt</tt>.</p>
<p>To help the dynamic loader do its job, a relocation entry is also added and specifies which place in the GOT to relocate for <tt class="docutils literal">ml_util_func</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt; readelf -r libmlpic.so
[...] snip output

Relocation section '.rel.plt' at offset 0x328 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00002000  00000107 R_386_JUMP_SLOT   00000000   __cxa_finalize
00002004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__
00002008  00000707 R_386_JUMP_SLOT   0000046c   ml_util_func
</pre></div>
<p>The last line means that the dynamic loader should place the value (address) of symbol <tt class="docutils literal">ml_util_func</tt> into <tt class="docutils literal">0x2008</tt> (which, recall, is the GOT entry for this function).</p>
<p>It would be interesting to see this GOT entry modification actually 
happen after the first call. Let's once again use GDB for the 
inspection.</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">&gt; gdb driver
[...] skipping output
(gdb) set environment LD_LIBRARY_PATH=.
(gdb) break ml_func
Breakpoint 1 at 0x80483c0
(gdb) run
Starting program: /pic_tests/driver

Breakpoint 1, ml_func (a=1, b=1) at ml_main.c:10
10        int c = b + ml_util_func(a);
(gdb)
</pre></div>
<p>We're now before the fist call to <tt class="docutils literal">ml_util_func</tt>. Recall that GOT is pointed to by <tt class="docutils literal">ebx</tt> in this code. Let's see what's in it:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">(gdb) i registers ebx
ebx            0x132ff4
</pre></div>
<p>And the offset to the entry we need is at <tt class="docutils literal">[ebx+0x14]</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">(gdb) x/w 0x133008
0x133008:     0x001313a6
</pre></div>
<p>Yep, the <tt class="docutils literal">0x3a6</tt> ending, looks right. Now, let's step until after the call to <tt class="docutils literal">ml_util_func</tt> and check again:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">(gdb) step
ml_util_func (a=1) at ml_main.c:5
5         return a + 1;
(gdb) x/w 0x133008
0x133008:     0x0013146c
</pre></div>
<p>The value at <tt class="docutils literal">0x133008</tt> was changed. Hence, <tt class="docutils literal">0x0013146c</tt> should be the real address of <tt class="docutils literal">ml_util_func</tt>, placed in there by the dynamic loader:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">(gdb) p &amp;ml_util_func
$1 = (int (*)(int)) 0x13146c &lt;ml_util_func&gt;
</pre></div>
<p>Just as expected.</p>
</div>
<div class="section" id="controlling-if-and-when-the-resolution-is-done-by-the-loader">
<h3>Controlling if and when the resolution is done by the loader</h3>
<p>This would be a good place to mention that the process of lazy symbol
 resolution performed by the dynamic loader can be configured with some 
environment variables (and corresponding flags to <tt class="docutils literal">ld</tt> when linking the shared library). This is sometimes useful for special performance requirements or debugging.</p>
<p>The <tt class="docutils literal">LD_BIND_NOW</tt> env var, when 
defined, tells the dynamic loader to always perform the resolution for 
all symbols at start-up time, and not lazily. You can easily verify this
 in action by setting this env var and re-running the previous sample 
with GDB. You'll see that the GOT entry for <tt class="docutils literal">ml_util_func</tt> contains its real address even before the first call to the function.</p>
<p>Conversely, the <tt class="docutils literal">LD_BIND_NOT</tt> env var
 tells the dynamic loader not to update the GOT entry at all. Each call 
to an external function will then go through the dynamic loader and be 
resolved anew.</p>
<p>The dynamic loader is configurable by other flags as well. I encourage you to go over <tt class="docutils literal">man ld.so</tt> - it contains some interesting information.</p>
</div>
<div class="section" id="the-costs-of-pic">
<h3>The costs of PIC</h3>
<p>This article started by stating the problems of load-time relocation 
and how the PIC approach fixes them. But PIC is also not without 
problems. One immediately apparent cost is the extra indirection 
required for all external references to data and code in PIC. That's an 
extra memory load for each reference to a global variable, and for each 
call to a function. How problematic this is in practice depends on the 
compiler, the CPU architecture and the particular application.</p>
<p>Another, less apparent cost, is the increased register usage required
 to implement PIC. In order to avoid locating the GOT too frequently, it
 makes sense for the compiler to generate code that keeps its address in
 a register (usually <tt class="docutils literal">ebx</tt>). But that 
ties down a whole register just for the sake of GOT. While not a big 
problem for RISC architectures that tend to have a lot of general 
purposes registers, it presents a performance problem for architectures 
like x86, which has a small amount of registers. PIC means having one 
general purpose register less, which adds up indirect costs since now 
more memory references have to be made.</p>
</div>
<div class="section" id="conclusion">
<h3>Conclusion</h3>
<p>This article explained what position independent code is, and how it 
helps create shared libraries with shareable read-only text sections. 
There are some tradeoffs when choosing between PIC and its alternative 
(load-time relocation), and the eventual outcome really depends on a lot
 of factors, like the CPU architecture on which the program is going to 
run.</p>
<p>That said, PIC is becoming more and more popular. Some non-Intel 
architectures like SPARC64 force PIC-only code for shared libraries, and
 many others (for example, ARM) include IP-relative addressing modes to 
make PIC more efficient. Both are true for the successor of x86, the x64
 architecture. I will discuss PIC on x64 in a future article.</p>
<p>The focus of this article, however, has not been on performance 
considerations or architectural decisions. My aim was to explain, given 
that PIC is used, <em>how it works</em>. If the explanation wasn't clear enough - please let me know in the comments and I will try to provide more information.</p>
<img class="align-center" src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/hline.jpg" style="width: 320px; height: 5px;">
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Unless all applications load this library into the exact same virtual memory address. But this usually isn't done on Linux.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><tt class="docutils literal">0x444</tt>
 (and all other addresses mentioned in this computation) is relative to 
the load address of the shared library, which is unknown until an 
executable actually loads it at runtime. Note how it doesn't matter in 
the code since it only juggles <em>relative</em> addresses.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>The astute reader may wonder why <tt class="docutils literal">.got</tt>
 is a separate section at all. Didn't I just show in the diagrams that 
it's located in the data section? In practice, it is. I don't want to 
get into the distinction between ELF sections and segments here, since 
that would take use too far away from the point. But briefly, any number
 of "data" sections can be defined for a library and mapped into a 
read-write segment. This doesn't really matter, as long as the ELF file 
is organized correctly. Separating the data segment into different 
logical sections provides modularity and makes the linker's job easier.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Note that <tt class="docutils literal">gdb</tt> skipped the part where <tt class="docutils literal">ecx</tt> is assigned. That's because it's kind-of considered to be part of the function's prolog (the real reason is in the way <tt class="docutils literal">gcc</tt>
 structures its debug info, of course). Several references to global 
data and functions are made inside a function, and a register pointing 
to GOT can serve all of them.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Shared library ELF objects actually come with special hash table sections for this purpose.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>The dynamic loader on Linux is just another shared library which gets loaded into the address space of all running processes.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>I placed <tt class="docutils literal">func</tt> in a separate code section, although in theory this could be the same one where the call to <tt class="docutils literal">func</tt> is made (i.e. in the same shared library). The "extra credit" section of <a class="reference external" href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/">this article</a> has information about why a call to an external function in the same shared library needs PIC (or relocation) as well.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>Recall that in the data reference example I promised to explain why there are apparently two GOT sections in the object: <tt class="docutils literal">.got</tt> and <tt class="docutils literal">.got.plt</tt>.
 Now it should become obvious that this is just to conveniently split 
the GOT entries required for global data from GOT entries required for 
the PLT. This is also why when the GOT offset is computed in functions, 
it points to <tt class="docutils literal">.got.plt</tt>, which comes right after <tt class="docutils literal">.got</tt>. This way, negative offsets lead us to <tt class="docutils literal">.got</tt>, while positive offsets lead us to <tt class="docutils literal">.got.plt</tt>. While convenient, such an arrangement is by no means compulsory. Both parts could be placed into a single <tt class="docutils literal">.got</tt> section.</td></tr>
</tbody>
</table>
</div>

    
            </div>
            <!-- /.entry-content -->

    <hr>
    <section class="comments" id="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"><iframe verticalscrolling="no" horizontalscrolling="no" src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/a.html" style="width: 100% ! important; border: medium none ! important; overflow: hidden ! important; height: 576px ! important;" title="Disqus" tabindex="0" scrolling="no" allowtransparency="true" data-disqus-uid="1" id="dsq-1" frameborder="0" width="100%"></iframe></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'elibenderskyswebsite'; // required: replace example with your forum shortname
            var disqus_identifier = 'position-independent-code-pic-in-shared-libraries';
            var disqus_url = 'http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries';
            var disqus_config = function () {
                this.language = "en";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        

    </section>
        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            © 2003-2015 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/jquery-2.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/bootstrap.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="Position%20Independent%20Code%20%28PIC%29%20in%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/respond.js"></script>

<script type="text/javascript">

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54426790-1', 'auto');
  ga('send', 'pageview');

</script>

</body></html>