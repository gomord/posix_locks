<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:og="http://ogp.me/ns#" xmlns:fb="https://www.facebook.com/2008/fbml"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Load-time relocation of shared libraries - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="http://eli.thegreenplace.net/favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/bootstrap.css" type="text/css">
    <link href="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/font-awesome.css" rel="stylesheet">

    <link href="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/style.css" type="text/css">

        <link href="http://eli.thegreenplace.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Eli Bendersky's website ATOM Feed">

<script src="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/analytics.js" async=""></script><script src="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/embed.js" async="" type="text/javascript"></script></head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://eli.thegreenplace.net/" class="navbar-brand">
                <img src="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/logosmall.png" width="32"> 
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="http://eli.thegreenplace.net/pages/about">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="http://eli.thegreenplace.net/pages/code">
                        <i class="fa fa-github"></i>
                        <span class="icon-label">Code</span>
                    </a>
                </li>
                <li>
                    <a href="http://eli.thegreenplace.net/archives/all">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries" rel="bookmark" title="Permalink to Load-time relocation of shared libraries">
                        Load-time relocation of shared libraries
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> August 25, 2011 at 14:47</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="http://eli.thegreenplace.net/tag/articles">Articles</a>
        ,
    <a href="http://eli.thegreenplace.net/tag/assembly">Assembly</a>
        ,
    <a href="http://eli.thegreenplace.net/tag/c-c">C &amp; C++</a>
        ,
    <a href="http://eli.thegreenplace.net/tag/linkers-and-loaders">Linkers and loaders</a>
        ,
    <a href="http://eli.thegreenplace.net/tag/linux">Linux</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                
        <p>This article's aim is to explain how a modern operating 
system makes it possible to use shared libraries with load-time 
relocation. It focuses on the Linux OS running on 32-bit x86, but the 
general principles apply to other OSes and CPUs as well.</p>
<p>Note that shared libraries have many names - shared libraries, shared
 objects, dynamic shared objects (DSOs), dynamically linked libraries 
(DLLs - if you're coming from a Windows background). For the sake of 
consistency, I will try to just use the name "shared library" throughout
 this article.</p>
<div class="section" id="loading-executables">
<h3>Loading executables</h3>
<p>Linux, similarly to other OSes with virtual memory support, loads 
executables to a fixed memory address. If we examine the ELF header of 
some random executable, we'll see an <em>Entry point address</em>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">$ readelf -h /usr/bin/uptime
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  [...] some header fields
  Entry point address:               0x8048470
  [...] some header fields
</pre></div>
<p>This is placed by the linker to tell the OS where to start executing the executable's code <a class="footnote-reference" href="#id14" id="id1">[1]</a>. And indeed if we then load the executable with GDB and examine the address <tt class="docutils literal">0x8048470</tt>, we'll see the first instructions of the executable's <tt class="docutils literal">.text</tt> segment there.</p>
<p>What this means is that the linker, when linking the executable, can fully resolve all <em>internal</em> symbol references (to functions and data) to fixed and final locations. The linker does some relocations of its own <a class="footnote-reference" href="#id15" id="id2">[2]</a>, but eventually the output it produces contains no additional relocations.</p>
<p>Or does it? Note that I emphasized the word <em>internal</em> in the previous paragraph. As long as the executable needs no shared libraries <a class="footnote-reference" href="#id16" id="id3">[3]</a>, it needs no relocations. But if it <em>does</em>
 use shared libraries (as do the vast majority of Linux applications), 
symbols taken from these shared libraries need to be relocated, because 
of how shared libraries are loaded.</p>
</div>
<div class="section" id="loading-shared-libraries">
<h3>Loading shared libraries</h3>
<p>Unlike executables, when shared libraries are being built, the linker
 can't assume a known load address for their code. The reason for this 
is simple. Each program can use any number of shared libraries, and 
there's simply no way to know in advance where any given shared library 
will be loaded in the process's virtual memory. Many solutions were 
invented for this problem over the years, but in this article I will 
just focus on the ones currently used by Linux.</p>
<p>But first, let's briefly examine the problem. Here's some sample C code <a class="footnote-reference" href="#id17" id="id4">[4]</a> which I compile into a shared library:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">int</span> myglob = <span style="color: #007f7f">42</span>;

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">ml_func</span>(<span style="color: #00007f; font-weight: bold">int</span> a, <span style="color: #00007f; font-weight: bold">int</span> b)
{
    myglob += a;
    <span style="color: #00007f; font-weight: bold">return</span> b + myglob;
}
</pre></div>
<p>Note how <tt class="docutils literal">ml_func</tt> references <tt class="docutils literal">myglob</tt> a few times. When translated to x86 assembly, this will involve a <tt class="docutils literal">mov</tt> instruction to pull the value of <tt class="docutils literal">myglob</tt> from its location in memory into a register. <tt class="docutils literal">mov</tt>
 requires an absolute address - so how does the linker know which 
address to place in it? The answer is - it doesn't. As I mentioned 
above, shared libraries have no pre-defined load address - it will be 
decided at runtime.</p>
<p>In Linux, the <em>dynamic loader</em> <a class="footnote-reference" href="#id18" id="id5">[5]</a>
 is a piece of code responsible for preparing programs for running. One 
of its tasks is to load shared libraries from disk into memory, when the
 running executable requests them. When a shared library is loaded into 
memory, it is then adjusted for its newly determined load location. It 
is the job of the dynamic loader to solve the problem presented in the 
previous paragraph.</p>
<p>There are two main approaches to solve this problem in Linux ELF shared libraries:</p>
<ol class="arabic simple">
<li>Load-time relocation</li>
<li>Position independent code (PIC)</li>
</ol>
<p>Although PIC is the more common and nowadays-recommended solution, in
 this article I will focus on load-time relocation. Eventually I plan to
 cover both approaches and write a separate article on PIC, and I think 
starting with load-time relocation will make PIC easier to explain 
later. (<em>Update 03.11.2011</em>: <a class="reference external" href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">the article about PIC</a> was published)</p>
</div>
<div class="section" id="linking-the-shared-library-for-load-time-relocation">
<h3>Linking the shared library for load-time relocation</h3>
<p>To create a shared library that has to be relocated at load-time, I'll compile it without the <tt class="docutils literal"><span class="pre">-fPIC</span></tt> flag (which would otherwise trigger PIC generation):</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">gcc -g -c ml_main.c -o ml_mainreloc.o
gcc -shared -o libmlreloc.so ml_mainreloc.o
</pre></div>
<p>The first interesting thing to see is the entry point of <tt class="docutils literal">libmlreloc.so</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">$ readelf -h libmlreloc.so
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  [...] some header fields
  Entry point address:               0x3b0
  [...] some header fields
</pre></div>
<p>For simplicity, the linker just links the shared object for address <tt class="docutils literal">0x0</tt> (the <tt class="docutils literal">.text</tt> section starting at <tt class="docutils literal">0x3b0</tt>), knowing that the loader will move it anyway. Keep this fact in mind - it will be useful later in the article.</p>
<p>Now let's look at the disassembly of the shared library, focusing on <tt class="docutils literal">ml_func</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">$ objdump -d -Mintel libmlreloc.so

libmlreloc.so:     file format elf32-i386

[...] skipping stuff

0000046c &lt;ml_func&gt;:
 46c: 55                      push   ebp
 46d: 89 e5                   mov    ebp,esp
 46f: a1 00 00 00 00          mov    eax,ds:0x0
 474: 03 45 08                add    eax,DWORD PTR [ebp+0x8]
 477: a3 00 00 00 00          mov    ds:0x0,eax
 47c: a1 00 00 00 00          mov    eax,ds:0x0
 481: 03 45 0c                add    eax,DWORD PTR [ebp+0xc]
 484: 5d                      pop    ebp
 485: c3                      ret

[...] skipping stuff
</pre></div>
<p>After the first two instructions which are part of the prologue <a class="footnote-reference" href="#id19" id="id6">[6]</a>, we see the compiled version of <tt class="docutils literal">myglob += a</tt> <a class="footnote-reference" href="#id20" id="id7">[7]</a>. The value of <tt class="docutils literal">myglob</tt> is taken from memory into <tt class="docutils literal">eax</tt>, incremented by <tt class="docutils literal">a</tt> (which is at <tt class="docutils literal">ebp+0x8</tt>) and then placed back into memory.</p>
<p>But wait, the <tt class="docutils literal">mov</tt> takes <tt class="docutils literal">myglob</tt>? Why? It appears that the actual operand of <tt class="docutils literal">mov</tt> is just <tt class="docutils literal">0x0</tt> <a class="footnote-reference" href="#id21" id="id8">[8]</a>. What gives? This is how relocations work. The linker places some provisional pre-defined value (<tt class="docutils literal">0x0</tt>
 in this case) into the  instruction stream, and then creates a special 
relocation entry pointing to this place. Let's examine the relocation 
entries for this shared library:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">$ readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x2fc contains 7 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00002008  00000008 R_386_RELATIVE
00000470  00000401 R_386_32          0000200C   myglob
00000478  00000401 R_386_32          0000200C   myglob
0000047d  00000401 R_386_32          0000200C   myglob
[...] skipping stuff
</pre></div>
<p>The <tt class="docutils literal">rel.dyn</tt> section of ELF is 
reserved for dynamic (load-time) relocations, to be consumed by the 
dynamic loader. There are 3 relocation entries for <tt class="docutils literal">myglob</tt> in the section showed above, since there are 3 references to <tt class="docutils literal">myglob</tt> in the disassembly. Let's decipher the first one.</p>
<p>It says: go to offset 0x470 in this object (shared library), and apply relocation of type <tt class="docutils literal">R_386_32</tt> to it for symbol <tt class="docutils literal">myglob</tt>. If we consult the ELF spec we see that relocation type <tt class="docutils literal">R_386_32</tt>
 means: take the value at the offset specified in the entry, add the 
address of the symbol to it, and place it back into the offset.</p>
<p>What do we have at offset <tt class="docutils literal">0x470</tt> in the object? Recall this instruction from the disassembly of <tt class="docutils literal">ml_func</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">46f:  a1 00 00 00 00          mov    eax,ds:0x0
</pre></div>
<p><tt class="docutils literal">a1</tt> encodes the <tt class="docutils literal">mov</tt> instruction, so its operand starts at the next address which is <tt class="docutils literal">0x470</tt>. This is the <tt class="docutils literal">0x0</tt> we see in the disassembly. So back to the relocation entry, we now see it says: add the address of <tt class="docutils literal">myglob</tt> to the operand of that <tt class="docutils literal">mov</tt> instruction. In other words it tells the dynamic loader - once you perform actual address assignment, put the real address of <tt class="docutils literal">myglob</tt> into <tt class="docutils literal">0x470</tt>, thus replacing the operand of <tt class="docutils literal">mov</tt> by the correct symbol value. Neat, huh?</p>
<p>Note also the "Sym. value" column in the relocation section, which contains <tt class="docutils literal">0x200C</tt> for <tt class="docutils literal">myglob</tt>. This is the offset of <tt class="docutils literal">myglob</tt> in the virtual memory image of the shared library (which, recall, the linker assumes is just loaded at <tt class="docutils literal">0x0</tt>). This value can also be examined by looking at the symbol table of the library, for example with <tt class="docutils literal">nm</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">$ nm libmlreloc.so
[...] skipping stuff
0000200c D myglob
</pre></div>
<p>This output also provides the offset of <tt class="docutils literal">myglob</tt> inside the library. <tt class="docutils literal">D</tt> means the symbol is in the initialized data section (<tt class="docutils literal">.data</tt>).</p>
</div>
<div class="section" id="load-time-relocation-in-action">
<h3>Load-time relocation in action</h3>
<p>To see the load-time relocation in action, I will use our shared 
library from a simple driver executable. When running this executable, 
the OS will load the shared library and relocate it appropriately.</p>
<p>Curiously, due to the <a class="reference external" href="http://en.wikipedia.org/wiki/Address_space_layout_randomization">address space layout randomization feature</a> which is enabled in Linux, relocation is relatively difficult to follow, because every time I run the executable, the <tt class="docutils literal">libmlreloc.so</tt> shared library gets placed in a different virtual memory address <a class="footnote-reference" href="#id22" id="id9">[9]</a>.</p>
<p>This is a rather weak deterrent, however. There is a way to make 
sense in it all. But first, let's talk about the segments our shared 
library consists of:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">$ readelf --segments libmlreloc.so

Elf file type is DYN (Shared object file)
Entry point 0x3b0
There are 6 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x00000000 0x00000000 0x004e8 0x004e8 R E 0x1000
  LOAD           0x000f04 0x00001f04 0x00001f04 0x0010c 0x00114 RW  0x1000
  DYNAMIC        0x000f18 0x00001f18 0x00001f18 0x000d0 0x000d0 RW  0x4
  NOTE           0x0000f4 0x000000f4 0x000000f4 0x00024 0x00024 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
  GNU_RELRO      0x000f04 0x00001f04 0x00001f04 0x000fc 0x000fc R   0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .eh_frame
   01     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   02     .dynamic
   03     .note.gnu.build-id
   04
   05     .ctors .dtors .jcr .dynamic .got
</pre></div>
<p>To follow the <tt class="docutils literal">myglob</tt> symbol, we're interested in the second segment listed here. Note a couple of things:</p>
<ul class="simple">
<li>In the section to segment mapping in the bottom, segment 01 is said to contain the <tt class="docutils literal">.data</tt> section, which is the home of <tt class="docutils literal">myglob</tt></li>
<li>The <tt class="docutils literal">VirtAddr</tt> column specifies that the second segment starts at <tt class="docutils literal">0x1f04</tt> and has size <tt class="docutils literal">0x10c</tt>, meaning that it extends until <tt class="docutils literal">0x2010</tt> and thus contains <tt class="docutils literal">myglob</tt> which is at <tt class="docutils literal">0x200C</tt>.</li>
</ul>
<p>Now let's use a nice tool Linux gives us to examine the load-time linking process - the <a class="reference external" href="http://linux.die.net/man/3/dl_iterate_phdr">dl_iterate_phdr function</a>,
 which allows an application to inquire at runtime which shared 
libraries it has loaded, and more importantly - take a peek at their 
program headers.</p>
<p>So I'm going to write the following code into <tt class="docutils literal">driver.c</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #007f00">#define _GNU_SOURCE</span>
<span style="color: #007f00">#include &lt;link.h&gt;</span>
<span style="color: #007f00">#include &lt;stdlib.h&gt;</span>
<span style="color: #007f00">#include &lt;stdio.h&gt;</span>


<span style="color: #00007f; font-weight: bold">static</span> <span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">header_handler</span>(<span style="color: #00007f; font-weight: bold">struct</span> dl_phdr_info* info, <span style="color: #00007f; font-weight: bold">size_t</span> size, <span style="color: #00007f; font-weight: bold">void</span>* data)
{
    printf(<span style="color: #7f007f">"name=%s (%d segments) address=%p\n"</span>,
            info-&gt;dlpi_name, info-&gt;dlpi_phnum, (<span style="color: #00007f; font-weight: bold">void</span>*)info-&gt;dlpi_addr);
    <span style="color: #00007f; font-weight: bold">for</span> (<span style="color: #00007f; font-weight: bold">int</span> j = <span style="color: #007f7f">0</span>; j &lt; info-&gt;dlpi_phnum; j++) {
         printf(<span style="color: #7f007f">"\t\t header %2d: address=%10p\n"</span>, j,
             (<span style="color: #00007f; font-weight: bold">void</span>*) (info-&gt;dlpi_addr + info-&gt;dlpi_phdr[j].p_vaddr));
         printf(<span style="color: #7f007f">"\t\t\t type=%u, flags=0x%X\n"</span>,
                 info-&gt;dlpi_phdr[j].p_type, info-&gt;dlpi_phdr[j].p_flags);
    }
    printf(<span style="color: #7f007f">"\n"</span>);
    <span style="color: #00007f; font-weight: bold">return</span> <span style="color: #007f7f">0</span>;
}


<span style="color: #00007f; font-weight: bold">extern</span> <span style="color: #00007f; font-weight: bold">int</span> ml_func(<span style="color: #00007f; font-weight: bold">int</span>, <span style="color: #00007f; font-weight: bold">int</span>);


<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">main</span>(<span style="color: #00007f; font-weight: bold">int</span> argc, <span style="color: #00007f; font-weight: bold">const</span> <span style="color: #00007f; font-weight: bold">char</span>* argv[])
{
    dl_iterate_phdr(header_handler, <span style="color: #00007f">NULL</span>);

    <span style="color: #00007f; font-weight: bold">int</span> t = ml_func(argc, argc);
    <span style="color: #00007f; font-weight: bold">return</span> t;
}
</pre></div>
<p><tt class="docutils literal">header_handler</tt> implements the callback for <tt class="docutils literal">dl_iterate_phdr</tt>.
 It will get called for all libraries and report their names and load 
addresses, along with all their segments. It also invokes <tt class="docutils literal">ml_func</tt>, which is taken from the <tt class="docutils literal">libmlreloc.so</tt> shared library.</p>
<p>To compile and link this driver with our shared library, run:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">gcc -g -c driver.c -o driver.o
gcc -o driver driver.o -L. -lmreloc
</pre></div>
<p>Running the driver stand-alone we get the information, but for each 
run the addresses are different. So what I'm going to do is run it under
 <tt class="docutils literal">gdb</tt> <a class="footnote-reference" href="#id23" id="id10">[10]</a>, see what it says, and then use <tt class="docutils literal">gdb</tt> to further query the process's memory space:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"> $ gdb -q driver
 Reading symbols from driver...done.
 (gdb) b driver.c:31
 Breakpoint 1 at 0x804869e: file driver.c, line 31.
 (gdb) r
 Starting program: driver
 [...] skipping output
 name=./libmlreloc.so (6 segments) address=0x12e000
                header  0: address=  0x12e000
                        type=1, flags=0x5
                header  1: address=  0x12ff04
                        type=1, flags=0x6
                header  2: address=  0x12ff18
                        type=2, flags=0x6
                header  3: address=  0x12e0f4
                        type=4, flags=0x4
                header  4: address=  0x12e000
                        type=1685382481, flags=0x6
                header  5: address=  0x12ff04
                        type=1685382482, flags=0x4

[...] skipping output
 Breakpoint 1, main (argc=1, argv=0xbffff3d4) at driver.c:31
 31    }
 (gdb)
</pre></div>
<p>Since <tt class="docutils literal">driver</tt> reports all the libraries it loads (even implicitly, like <tt class="docutils literal">libc</tt> or the dynamic loader itself), the output is lengthy and I will just focus on the report about <tt class="docutils literal">libmlreloc.so</tt>. Note that the 6 segments are the same segments reported by <tt class="docutils literal">readelf</tt>, but this time relocated into their final memory locations.</p>
<p>Let's do some math. The output says <tt class="docutils literal">libmlreloc.so</tt> was placed in virtual address <tt class="docutils literal">0x12e000</tt>. We're interested in the second segment, which as we've seen in <tt class="docutils literal">readelf</tt> is at ofset <tt class="docutils literal">0x1f04</tt>. Indeed, we see in the output it was loaded to address <tt class="docutils literal">0x12ff04</tt>. And since <tt class="docutils literal">myglob</tt> is at offset <tt class="docutils literal">0x200c</tt> in the file, we'd expect it to now be at address <tt class="docutils literal">0x13000c</tt>.</p>
<p>So, let's ask GDB:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">(gdb) p &amp;myglob
$1 = (int *) 0x13000c
</pre></div>
<p>Excellent! But what about the code of <tt class="docutils literal">ml_func</tt> which refers to <tt class="docutils literal">myglob</tt>? Let's ask GDB again:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">(gdb) set disassembly-flavor intel
(gdb) disas ml_func
Dump of assembler code for function ml_func:
   0x0012e46c &lt;+0&gt;:   push   ebp
   0x0012e46d &lt;+1&gt;:   mov    ebp,esp
   0x0012e46f &lt;+3&gt;:   mov    eax,ds:0x13000c
   0x0012e474 &lt;+8&gt;:   add    eax,DWORD PTR [ebp+0x8]
   0x0012e477 &lt;+11&gt;:  mov    ds:0x13000c,eax
   0x0012e47c &lt;+16&gt;:  mov    eax,ds:0x13000c
   0x0012e481 &lt;+21&gt;:  add    eax,DWORD PTR [ebp+0xc]
   0x0012e484 &lt;+24&gt;:  pop    ebp
   0x0012e485 &lt;+25&gt;:  ret
End of assembler dump.
</pre></div>
<p>As expected, the real address of <tt class="docutils literal">myglob</tt> was placed in all the <tt class="docutils literal">mov</tt> instructions referring to it, just as the relocation entries specified.</p>
</div>
<div class="section" id="relocating-function-calls">
<h3>Relocating function calls</h3>
<p>So far this article demonstrated relocation of data references - using the global variable <tt class="docutils literal">myglob</tt>
 as an example. Another thing that needs to be relocated is code 
references - in other words, function calls. This section is a brief 
guide on how this gets done. The pace is much faster than in the rest of
 this article, since I can now assume the reader understands what 
relocation is all about.</p>
<p>Without further ado, let's get to it. I've modified the code of the shared library to be the following:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #00007f; font-weight: bold">int</span> myglob = <span style="color: #007f7f">42</span>;

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">ml_util_func</span>(<span style="color: #00007f; font-weight: bold">int</span> a)
{
    <span style="color: #00007f; font-weight: bold">return</span> a + <span style="color: #007f7f">1</span>;
}

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">ml_func</span>(<span style="color: #00007f; font-weight: bold">int</span> a, <span style="color: #00007f; font-weight: bold">int</span> b)
{
    <span style="color: #00007f; font-weight: bold">int</span> c = b + ml_util_func(a);
    myglob += c;
    <span style="color: #00007f; font-weight: bold">return</span> b + myglob;
}
</pre></div>
<p><tt class="docutils literal">ml_util_func</tt> was added and it's being used by <tt class="docutils literal">ml_func</tt>. Here's the disassembly of <tt class="docutils literal">ml_func</tt> in the linked shared library:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">000004a7 &lt;ml_func&gt;:
 4a7:   55                      push   ebp
 4a8:   89 e5                   mov    ebp,esp
 4aa:   83 ec 14                sub    esp,0x14
 4ad:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
 4b0:   89 04 24                mov    DWORD PTR [esp],eax
 4b3:   e8 fc ff ff ff          call   4b4 &lt;ml_func+0xd&gt;
 4b8:   03 45 0c                add    eax,DWORD PTR [ebp+0xc]
 4bb:   89 45 fc                mov    DWORD PTR [ebp-0x4],eax
 4be:   a1 00 00 00 00          mov    eax,ds:0x0
 4c3:   03 45 fc                add    eax,DWORD PTR [ebp-0x4]
 4c6:   a3 00 00 00 00          mov    ds:0x0,eax
 4cb:   a1 00 00 00 00          mov    eax,ds:0x0
 4d0:   03 45 0c                add    eax,DWORD PTR [ebp+0xc]
 4d3:   c9                      leave
 4d4:   c3                      ret
</pre></div>
<p>What's interesting here is the instruction at address <tt class="docutils literal">0x4b3</tt> - it's the call to <tt class="docutils literal">ml_util_func</tt>. Let's dissect it:</p>
<p><tt class="docutils literal">e8</tt> is the opcode for <tt class="docutils literal">call</tt>. The argument of this <tt class="docutils literal">call</tt> is the offset relative to the next instruction. In the disassembly above, this argument is <tt class="docutils literal">0xfffffffc</tt>, or simply <tt class="docutils literal"><span class="pre">-4</span></tt>. So the <tt class="docutils literal">call</tt>
 currently points to itself. This clearly isn't right - but let's not 
forget about relocation. Here's what the relocation section of the 
shared library looks like now:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">$ readelf -r libmlreloc.so

Relocation section '.rel.dyn' at offset 0x324 contains 8 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00002008  00000008 R_386_RELATIVE
000004b4  00000502 R_386_PC32        0000049c   ml_util_func
000004bf  00000401 R_386_32          0000200c   myglob
000004c7  00000401 R_386_32          0000200c   myglob
000004cc  00000401 R_386_32          0000200c   myglob
[...] skipping stuff
</pre></div>
<p>If we compare it to the previous invocation of <tt class="docutils literal">readelf <span class="pre">-r</span></tt>, we'll notice a new entry added for <tt class="docutils literal">ml_util_func</tt>. This entry points at address <tt class="docutils literal">0x4b4</tt> which is the argument of the <tt class="docutils literal">call</tt> instruction, and its type is <tt class="docutils literal">R_386_PC32</tt>. This relocation type is more complicated than <tt class="docutils literal">R_386_32</tt>, but not by much.</p>
<p>It means the following: take the value at the offset specified in the
 entry, add the address of the symbol to it, subtract the address of the
 offset itself, and place it back into the word at the offset. Recall 
that this relocation is done at <em>load-time</em>, when the final load 
addresses of the symbol and the relocated offset itself are already 
known. These final addresses participate in the computation.</p>
<p>What does this do? Basically, it's a <em>relative</em> relocation, 
taking its location into account and thus suitable for arguments of 
instructions with relative addressing (which the <tt class="docutils literal">e8 call</tt> is). I promise it will become clearer once we get to the real numbers.</p>
<p>I'm now going to build the driver code and run it under GDB again, to
 see this relocation in action. Here's the GDB session, followed by 
explanations:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"> $ gdb -q driver
 Reading symbols from driver...done.
 (gdb) b driver.c:31
 Breakpoint 1 at 0x804869e: file driver.c, line 31.
 (gdb) r
 Starting program: driver
 [...] skipping output
 name=./libmlreloc.so (6 segments) address=0x12e000
               header  0: address=  0x12e000
                       type=1, flags=0x5
               header  1: address=  0x12ff04
                       type=1, flags=0x6
               header  2: address=  0x12ff18
                       type=2, flags=0x6
               header  3: address=  0x12e0f4
                       type=4, flags=0x4
               header  4: address=  0x12e000
                       type=1685382481, flags=0x6
               header  5: address=  0x12ff04
                       type=1685382482, flags=0x4

[...] skipping output
Breakpoint 1, main (argc=1, argv=0xbffff3d4) at driver.c:31
31    }
(gdb)  set disassembly-flavor intel
(gdb) disas ml_util_func
Dump of assembler code for function ml_util_func:
   0x0012e49c &lt;+0&gt;:   push   ebp
   0x0012e49d &lt;+1&gt;:   mov    ebp,esp
   0x0012e49f &lt;+3&gt;:   mov    eax,DWORD PTR [ebp+0x8]
   0x0012e4a2 &lt;+6&gt;:   add    eax,0x1
   0x0012e4a5 &lt;+9&gt;:   pop    ebp
   0x0012e4a6 &lt;+10&gt;:  ret
End of assembler dump.
(gdb) disas /r ml_func
Dump of assembler code for function ml_func:
   0x0012e4a7 &lt;+0&gt;:    55     push   ebp
   0x0012e4a8 &lt;+1&gt;:    89 e5  mov    ebp,esp
   0x0012e4aa &lt;+3&gt;:    83 ec 14       sub    esp,0x14
   0x0012e4ad &lt;+6&gt;:    8b 45 08       mov    eax,DWORD PTR [ebp+0x8]
   0x0012e4b0 &lt;+9&gt;:    89 04 24       mov    DWORD PTR [esp],eax
   0x0012e4b3 &lt;+12&gt;:   e8 e4 ff ff ff call   0x12e49c &lt;ml_util_func&gt;
   0x0012e4b8 &lt;+17&gt;:   03 45 0c       add    eax,DWORD PTR [ebp+0xc]
   0x0012e4bb &lt;+20&gt;:   89 45 fc       mov    DWORD PTR [ebp-0x4],eax
   0x0012e4be &lt;+23&gt;:   a1 0c 00 13 00 mov    eax,ds:0x13000c
   0x0012e4c3 &lt;+28&gt;:   03 45 fc       add    eax,DWORD PTR [ebp-0x4]
   0x0012e4c6 &lt;+31&gt;:   a3 0c 00 13 00 mov    ds:0x13000c,eax
   0x0012e4cb &lt;+36&gt;:   a1 0c 00 13 00 mov    eax,ds:0x13000c
   0x0012e4d0 &lt;+41&gt;:   03 45 0c       add    eax,DWORD PTR [ebp+0xc]
   0x0012e4d3 &lt;+44&gt;:   c9     leave
   0x0012e4d4 &lt;+45&gt;:   c3     ret
End of assembler dump.
(gdb)
</pre></div>
<p>The important parts here are:</p>
<ol class="arabic simple">
<li>In the printout from <tt class="docutils literal">driver</tt> we see that the first segment (the code segment) of <tt class="docutils literal">libmlreloc.so</tt> has been mapped to <tt class="docutils literal">0x12e000</tt> <a class="footnote-reference" href="#id24" id="id11">[11]</a></li>
<li><tt class="docutils literal">ml_util_func</tt> was loaded to address <tt class="docutils literal">0x0012e49c</tt></li>
<li>The address of the relocated offset is <tt class="docutils literal">0x0012e4b4</tt></li>
<li>The call in <tt class="docutils literal">ml_func</tt> to <tt class="docutils literal">ml_util_func</tt> was patched to place <tt class="docutils literal">0xffffffe4</tt> in the argument (I disassembled <tt class="docutils literal">ml_func</tt> with the <tt class="docutils literal">/r</tt> flag to show raw hex in addition to disassembly), which is interpreted as the correct offset to <tt class="docutils literal">ml_util_func</tt>.</li>
</ol>
<p>Obviously we're most interested in how (4) was done. Again, it's time for some math. Interpreting the <tt class="docutils literal">R_386_PC32</tt> relocation entry mentioned above, we have:</p>
<p>Take the value at the offset specified in the entry (<tt class="docutils literal">0xfffffffc</tt>), add the address of the symbol to it (<tt class="docutils literal">0x0012e49c</tt>), subtract the address of the offset itself (<tt class="docutils literal">0x0012e4b4</tt>), and place it back into the word at the offset. Everything is done assuming 32-bit 2-s complement, of course. The result is <tt class="docutils literal">0xffffffe4</tt>, as expected.</p>
</div>
<div class="section" id="extra-credit-why-was-the-call-relocation-needed">
<h3>Extra credit: Why was the call relocation needed?</h3>
<p>This is a "bonus" section that discusses some peculiarities of the 
implementation of shared library loading in Linux. If all you wanted was
 to understand how relocations are done, you can safely skip it.</p>
<p>When trying to understand the call relocation of <tt class="docutils literal">ml_util_func</tt>, I must admit I scratched my head for some time. Recall that the argument of <tt class="docutils literal">call</tt> is a <em>relative offset</em>. Surely the offset between the <tt class="docutils literal">call</tt> and <tt class="docutils literal">ml_util_func</tt>
 itself doesn't change when the library is loaded - they both are in the
 code segment which gets moved as one whole chunk. So why is the 
relocation needed at all?</p>
<p>Here's a small experiment to try: go back to the code of the shared library, add <tt class="docutils literal">static</tt> to the declaration of <tt class="docutils literal">ml_util_func</tt>. Re-compile and look at the output of <tt class="docutils literal">readelf <span class="pre">-r</span></tt> again.</p>
<p>Done? Anyway, I will reveal the outcome - the relocation is gone! Examine the disassembly of <tt class="docutils literal">ml_func</tt> - there's now a correct offset placed as the argument of <tt class="docutils literal">call</tt> - no relocation required. What's going on?</p>
<p>When tying global symbol references to their actual definitions, the 
dynamic loader has some rules about the order in which shared libraries 
are searched. The user can also influence this order by setting the <tt class="docutils literal">LD_PRELOAD</tt> environment variable.</p>
<p>There are too many details to cover here, so if you're really 
interested you'll have to take a look at the ELF standard, the dynamic 
loader man page and do some Googling. In short, however, when <tt class="docutils literal">ml_util_func</tt>
 is global, it may be overridden in the executable or another shared 
library, so when linking our shared library, the linker can't just 
assume the offset is known and hard-code it <a class="footnote-reference" href="#id25" id="id12">[12]</a>.
 It makes all references to global symbols relocatable in order to allow
 the dynamic loader to decide how to resolve them. This is why declaring
 the function <tt class="docutils literal">static</tt> makes a difference - since it's no longer global or exported, the linker can hard-code its offset in the code.</p>
</div>
<div class="section" id="extra-credit-2-referencing-shared-library-data-from-the-executable">
<h3>Extra credit #2: Referencing shared library data from the executable</h3>
<p>Again, this is a bonus section that discusses an advanced topic. It can be skipped safely if you're tired of this stuff.</p>
<p>In the example above, <tt class="docutils literal">myglob</tt> was only used internally in the shared library. What happens if we reference it from the program (<tt class="docutils literal">driver.c</tt>)? After all, <tt class="docutils literal">myglob</tt> is a global variable and thus visible externally.</p>
<p>Let's modify <tt class="docutils literal">driver.c</tt> to the following (note I've removed the segment iteration code):</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #007f00">#include &lt;stdio.h&gt;</span>

<span style="color: #00007f; font-weight: bold">extern</span> <span style="color: #00007f; font-weight: bold">int</span> ml_func(<span style="color: #00007f; font-weight: bold">int</span>, <span style="color: #00007f; font-weight: bold">int</span>);
<span style="color: #00007f; font-weight: bold">extern</span> <span style="color: #00007f; font-weight: bold">int</span> myglob;

<span style="color: #00007f; font-weight: bold">int</span> <span style="color: #00007f">main</span>(<span style="color: #00007f; font-weight: bold">int</span> argc, <span style="color: #00007f; font-weight: bold">const</span> <span style="color: #00007f; font-weight: bold">char</span>* argv[])
{
    printf(<span style="color: #7f007f">"addr myglob = %p\n"</span>, (<span style="color: #00007f; font-weight: bold">void</span>*)&amp;myglob);
    <span style="color: #00007f; font-weight: bold">int</span> t = ml_func(argc, argc);
    <span style="color: #00007f; font-weight: bold">return</span> t;
}
</pre></div>
<p>It now prints the address of <tt class="docutils literal">myglob</tt>. The output is:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">addr myglob = 0x804a018
</pre></div>
<p>Wait, something doesn't compute here. Isn't <tt class="docutils literal">myglob</tt> in the shared library's address space? <tt class="docutils literal">0x804xxxx</tt> looks like the program's address space. What's going on?</p>
<p>Recall that the program/executable is not relocatable, and thus its 
data addresses have to bound at link time. Therefore, the linker has to 
create a copy of the variable in the program's address space, and the 
dynamic loader will use <em>that</em> as the relocation address. This is similar to the discussion in the previous section - in a sense, <tt class="docutils literal">myglob</tt>
 in the main program overrides the one in the shared library, and 
according to the global symbol lookup rules, it's being used instead. If
 we examine <tt class="docutils literal">ml_func</tt> in GDB, we'll see the correct reference made to <tt class="docutils literal">myglob</tt>:</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">0x0012e48e &lt;+23&gt;:      a1 18 a0 04 08 mov    eax,ds:0x804a018
</pre></div>
<p>This makes sense because a <tt class="docutils literal">R_386_32</tt> relocation for <tt class="docutils literal">myglob</tt> still exists in <tt class="docutils literal">libmlreloc.so</tt>, and the dynamic loader makes it point to the correct place where <tt class="docutils literal">myglob</tt> now lives.</p>
<p>This is all great, but something is missing. <tt class="docutils literal">myglob</tt>
 is initialized in the shared library (to 42) - how does this 
initialization value get to the address space of the program? It turns 
out there's a special relocation entry that the linker builds into the <em>program</em> (so far we've only been examining relocation entries in the shared library):</p>
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%">$ readelf -r driver

Relocation section '.rel.dyn' at offset 0x3c0 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ff0  00000206 R_386_GLOB_DAT    00000000   __gmon_start__
0804a018  00000605 R_386_COPY        0804a018   myglob
[...] skipping stuff
</pre></div>
<p>Note the <tt class="docutils literal">R_386_COPY</tt> relocation for <tt class="docutils literal">myglob</tt>.
 It simply means: copy the value from the symbol's address into this 
offset. The dynamic loader performs this when it loads the shared 
library. How does it know how much to copy? The symbol table section 
contains the size of each symbol; for example the size for <tt class="docutils literal">myglob</tt> in the <tt class="docutils literal">.symtab</tt> section of <tt class="docutils literal">libmlreloc.so</tt> is 4.</p>
<p>I think this is a pretty cool example that shows how the process of 
executable linking and loading is orchestrated together. The linker puts
 special instructions in the output for the dynamic loader to consume 
and execute.</p>
</div>
<div class="section" id="conclusion">
<h3>Conclusion</h3>
<p>Load-time relocation is one of the methods used in Linux (and other 
OSes) to resolve internal data and code references in shared libraries 
when loading them into memory. These days, position independent code 
(PIC) is a more popular approach, and some modern systems (such as 
x86-64) no longer support load-time relocation.</p>
<p>Still, I decided to write an article on load-time relocation for two 
reasons. First, load-time relocation has a couple of advantages over PIC
 on some systems, especially in terms of performance. Second, load-time 
relocation is IMHO simpler to understand without prior knowledge, which 
will make PIC easier to explain in the future. (<em>Update 03.11.2011</em>: <a class="reference external" href="http://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">the article about PIC</a> was published)</p>
<p>Regardless of the motivation, I hope this article has helped to shed 
some light on the magic going behind the scenes of linking and loading 
shared libraries in a modern OS.</p>
<img class="align-center" src="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/hline.jpg" style="width: 320px; height: 5px;">
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>For some more information about this entry point, see the section "Digression – process addresses and entry point" of <a class="reference external" href="http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints/">this article</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><em>Link-time relocation</em>
 happens in the process of combining multiple object files into an 
executable (or shared library). It involves quite a lot of relocations 
to resolve symbol references between the object files. Link-time 
relocation is a more complex topic than load-time relocation, and I 
won't cover it in this article.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>This can be made possible by compiling all your libraries into static libraries (with <tt class="docutils literal">ar</tt> combining object files instead <tt class="docutils literal">gcc <span class="pre">-shared</span></tt>), and providing the <tt class="docutils literal"><span class="pre">-static</span></tt> flag to <tt class="docutils literal">gcc</tt> when linking the executable - to avoid linkage with the shared version of <tt class="docutils literal">libc</tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><tt class="docutils literal">ml</tt> simply stands for "my library". Also, the code itself is absolutely non-sensical and only used for purposes of demonstration.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>Also called "dynamic linker". It's a shared object itself (though it can also run as an executable), residing at <tt class="docutils literal"><span class="pre">/lib/ld-linux.so.2</span></tt> (the last number is the SO version and may be different).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>If you're not familiar with how x86 structures its stack frames, this would be a good time to read <a class="reference external" href="http://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/">this article</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>You can provide the <tt class="docutils literal"><span class="pre">-l</span></tt> flag to <tt class="docutils literal">objdump</tt>
 to add C source lines into the disassembly, making it clearer what gets
 compiled to what. I've omitted it here to make the output shorter.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>I'm looking at the left-hand side of the output of <tt class="docutils literal">objdump</tt>, where the raw memory bytes are. <tt class="docutils literal">a1 00 00 00 00</tt> means <tt class="docutils literal">mov</tt> to <tt class="docutils literal">eax</tt> with operand <tt class="docutils literal">0x0</tt>, which is interpreted by the disassembler as <tt class="docutils literal">ds:0x0</tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td>So <tt class="docutils literal">ldd</tt> invoked on the executable will report a different load address for the shared library each time it's run.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[10]</a></td><td>Experienced readers will probably note that I could ask GDB about <tt class="docutils literal">i shared</tt> to get the load-address of the shared library. However, <tt class="docutils literal">i shared</tt>
 only mentions the load location of the whole library (or, even more 
accurately, its entry point), and I was interested in the segments.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[11]</a></td><td>What, <tt class="docutils literal">0x12e000</tt>
 again? Didn't I just talk about load-address randomization? It turns 
out the dynamic loader can be manipulated to turn this off, for purposes
 of debugging. This is exactly what GDB is doing.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[12]</a></td><td>Unless it's passed the <tt class="docutils literal"><span class="pre">-Bsymbolic</span></tt> flag. Read all about it in the man page of <tt class="docutils literal">ld</tt>.</td></tr>
</tbody>
</table>
</div>

    
            </div>
            <!-- /.entry-content -->

    <hr>
    <section class="comments" id="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"><iframe verticalscrolling="no" horizontalscrolling="no" src="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/a.html" style="width: 100% ! important; border: medium none ! important; overflow: hidden ! important; height: 1712px ! important;" title="Disqus" tabindex="0" scrolling="no" allowtransparency="true" data-disqus-uid="1" id="dsq-1" frameborder="0" width="100%"></iframe></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'elibenderskyswebsite'; // required: replace example with your forum shortname
            var disqus_identifier = 'load-time-relocation-of-shared-libraries';
            var disqus_url = 'http://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries';
            var disqus_config = function () {
                this.language = "en";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        

    </section>
        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            © 2003-2015 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/jquery-2.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/bootstrap.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="Load-time%20relocation%20of%20shared%20libraries%20-%20Eli%20Bendersky%27s%20website_files/respond.js"></script>

<script type="text/javascript">

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54426790-1', 'auto');
  ga('send', 'pageview');

</script>

</body></html>